<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>è“ç´«æ¢¦å¢ƒ - å¼ºè¿çº¿æµå…‰ç‰ˆ</title>
    <style>
        /* --- åŸºç¡€æ ·å¼ --- */
        * { margin: 0; padding: 0; box-sizing: border-box; user-select: none; }
        body {
            width: 100vw; height: 100vh;
            background: #000;
            overflow: hidden;
            font-family: 'Segoe UI', Roboto, sans-serif;
            color: #d1d5db;
        }
        canvas { display: block; position: absolute; top: 0; left: 0; z-index: 1; }

        /* --- é¡¶éƒ¨æ’­æ”¾æ§ä»¶ --- */
        #top-ui {
            position: absolute;
            top: 25px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 100;
            display: flex;
            align-items: center;
            gap: 15px;
            background: rgba(10, 10, 25, 0.75);
            backdrop-filter: blur(12px);
            padding: 10px 25px;
            border-radius: 50px;
            border: 1px solid rgba(100, 100, 255, 0.25);
            box-shadow: 0 0 20px rgba(50, 50, 255, 0.2);
        }
        
        button, label {
            background: transparent;
            border: 1px solid rgba(130, 130, 255, 0.3);
            color: #e0e0ff;
            padding: 6px 16px;
            border-radius: 20px;
            cursor: pointer;
            font-size: 13px;
            transition: 0.3s;
            white-space: nowrap;
        }
        button:hover, label:hover { 
            background: rgba(100, 100, 255, 0.2); 
            border-color: #a0a0ff; 
            color: #fff;
            box-shadow: 0 0 10px rgba(100, 100, 255, 0.4);
        }
        button:disabled { opacity: 0.4; cursor: not-allowed; box-shadow: none; }
        input[type="file"] { display: none; }
        #song-info { 
            max-width: 180px; white-space: nowrap; overflow: hidden; 
            text-overflow: ellipsis; font-size: 12px; color: #8899ff; 
        }

        /* --- å³ä¾§æ‚¬æµ®æ§åˆ¶é¢æ¿ --- */
        #settings-panel {
            position: absolute;
            top: 50%;
            right: 20px;
            transform: translateY(-50%);
            width: 260px;
            background: rgba(8, 8, 16, 0.85);
            backdrop-filter: blur(15px);
            border: 1px solid rgba(255, 255, 255, 0.08);
            border-radius: 16px;
            padding: 25px 20px;
            z-index: 90;
            box-shadow: 0 20px 50px rgba(0,0,0,0.6);
            transition: transform 0.4s cubic-bezier(0.22, 1, 0.36, 1);
        }
        
        #settings-panel.collapsed { transform: translate(300px, -50%); }

        .toggle-btn {
            position: absolute;
            left: -30px;
            top: 50%;
            transform: translateY(-50%);
            width: 30px;
            height: 60px;
            background: rgba(8, 8, 16, 0.85);
            border-radius: 8px 0 0 8px;
            border: 1px solid rgba(255, 255, 255, 0.08);
            border-right: none;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            color: #8899ff;
            font-size: 12px;
        }

        .panel-header {
            font-size: 14px;
            font-weight: 600;
            color: #fff;
            margin-bottom: 20px;
            text-transform: uppercase;
            letter-spacing: 2px;
            border-bottom: 1px solid rgba(255,255,255,0.1);
            padding-bottom: 10px;
        }

        .control-group { margin-bottom: 18px; }
        .control-label { 
            display: flex; justify-content: space-between; 
            font-size: 12px; color: #aab; margin-bottom: 8px; 
        }
        
        input[type="range"] {
            -webkit-appearance: none; width: 100%; height: 4px; 
            background: rgba(255,255,255,0.1); outline: none; border-radius: 2px;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none; width: 14px; height: 14px; 
            background: #6a6aff; border-radius: 50%; cursor: pointer; 
            box-shadow: 0 0 10px rgba(106, 106, 255, 0.5);
            transition: transform 0.2s;
        }
        input[type="range"]::-webkit-slider-thumb:hover { transform: scale(1.3); background: #fff; }

        /* --- åº•éƒ¨çŠ¶æ€ --- */
        #status-bar {
            position: absolute;
            bottom: 25px;
            width: 100%;
            text-align: center;
            font-size: 13px;
            color: rgba(150, 150, 255, 0.5);
            letter-spacing: 1px;
            pointer-events: none;
            z-index: 50;
            text-shadow: 0 0 5px rgba(100,100,255,0.5);
        }
    </style>
</head>
<body>

    <!-- é¡¶éƒ¨éŸ³ä¹æ§åˆ¶ -->
    <div id="top-ui">
        <label for="file-upload">ğŸµ å¯¼å…¥éŸ³ä¹</label>
        <input type="file" id="file-upload" accept="audio/*">
        <div id="song-info">ç­‰å¾…åŠ è½½...</div>
        <button id="btn-play" disabled>â–¶</button>
        <button id="btn-pause" disabled>â¸</button>
        <button id="btn-reset">â†º</button>
    </div>

    <!-- å³ä¾§å‚æ•°æ§åˆ¶é¢æ¿ -->
    <div id="settings-panel">
        <div class="toggle-btn" onclick="document.getElementById('settings-panel').classList.toggle('collapsed')">âš™</div>
        <div class="panel-header">ç²’å­å‚æ•°ç¼–è¾‘å™¨</div>
        
        <div class="control-group">
            <div class="control-label"><span>ç²’å­æ•°é‡</span><span id="val-count">1200</span></div>
            <input type="range" id="rng-count" min="500" max="3000" step="100" value="1200">
        </div>

        <div class="control-group">
            <div class="control-label"><span>ç²’å­å¤§å°</span><span id="val-size">2.0px</span></div>
            <input type="range" id="rng-size" min="0.5" max="5.0" step="0.1" value="2.0">
        </div>

        <div class="control-group">
            <div class="control-label"><span>è‰²è°ƒå¾®è°ƒ (è“/ç´«)</span><span id="val-hue">0Â°</span></div>
            <input type="range" id="rng-hue" min="-30" max="30" step="1" value="0">
        </div>

        <div class="control-group">
            <div class="control-label"><span>äº®åº¦å¢ç›Š</span><span id="val-bright">100%</span></div>
            <input type="range" id="rng-bright" min="50" max="250" step="5" value="100">
        </div>

        <div class="control-group">
            <div class="control-label"><span>æ‹–å°¾/è¾‰å…‰ (Fade)</span><span id="val-trail">20%</span></div>
            <input type="range" id="rng-trail" min="5" max="60" step="1" value="20">
        </div>
        
        <div style="font-size:11px; color:#556; text-align:center; margin-top:15px;">
            æ»šè½®ç¼©æ”¾ / å·¦é”®æ‹–æ‹½æ—‹è½¬
        </div>
    </div>

    <div id="status-bar">ç³»ç»Ÿå°±ç»ª</div>
    <canvas id="canvas"></canvas>

<script>
/**
 * æ„è¯†æ¶Œç°å¯è§†åŒ– - å¼ºè¿çº¿æµå…‰ç‰ˆ
 * ä¼˜åŒ–ç‚¹ï¼šå‡å¼±å…·è±¡æŠ–åŠ¨ï¼Œå¢å¼ºè¿çº¿å¯è§åº¦ï¼Œå¢åŠ æ¶Ÿæ¼ªå…‰æ•ˆ
 */

// --- 1. å…¨å±€é…ç½®ä¸çŠ¶æ€ ---
const CONFIG = {
    particleCount: 1200,
    baseSize: 2.0,
    hueOffset: 0,      
    brightness: 1.0,   
    trailAlpha: 0.20,  

    zoom: 850,         
    baseHueMin: 210,   
    baseHueMax: 270,   
    rotationSpeed: 0.0015
};

const STATES = {
    IDLE: 0,        
    FORMING: 1,     
    HOLDING: 2,     
    DISPERSING: 3   
};

let canvas, ctx, w, h;
let particles = [];
let currentState = STATES.IDLE;
let stateStartTime = 0;
let currentShapeName = 'chaos';
let audioCtx, analyser, dataArray, audioSource, audioBuffer;
let isPlaying = false;
let shapeUpdateTimer = 0;

const MOUSE = { x: 0, y: 0, isDown: false, lastX: 0, lastY: 0, rotX: 0, rotY: 0 };

// --- 2. 3D æ•°å­¦æ¨¡å‹åº“ ---
const MathShapes = {
    chaos: (i, total) => ({
        x: (Math.random() - 0.5) * w * 1.5,
        y: (Math.random() - 0.5) * h * 1.5,
        z: (Math.random() - 0.5) * 1000
    }),
    
    flower: (i, total) => {
        const phi = Math.acos(-1 + (2 * i) / total);
        const theta = Math.sqrt(total * Math.PI) * phi;
        const petal = 0.8 + 0.3 * Math.sin(6 * theta) * Math.sin(4 * phi);
        const r = 380 * petal;
        return {
            x: r * Math.sin(phi) * Math.cos(theta),
            y: r * Math.sin(phi) * Math.sin(theta),
            z: r * Math.cos(phi) * 0.6
        };
    },

    whale: (i, total) => {
        const isBody = i < total * 0.85;
        if (isBody) {
            const t = (i / (total * 0.85)) * Math.PI * 2 - Math.PI;
            const width = 130 * Math.cos(t / 2.2);
            const len = t * 180;
            const angle = i * 0.5; 
            return {
                x: len,
                y: width * Math.sin(angle) * Math.cos(t/2),
                z: width * Math.cos(angle)
            };
        } else {
            const t = (i - total * 0.85) / (total * 0.15); 
            const tailW = 160 * t;
            const tailLen = 350 + t * 120;
            const fanAngle = (Math.random() - 0.5) * 2.5; 
            return {
                x: -tailLen,
                y: Math.sin(fanAngle) * tailW * 0.4,
                z: Math.cos(fanAngle) * tailW 
            };
        }
    },

    mountain: (i, total) => {
        const r = 10 + 600 * Math.sqrt(i / total);
        const theta = i * 1.0; 
        const x = r * Math.cos(theta);
        const z = r * Math.sin(theta);
        const dist = Math.sqrt(x*x + z*z);
        const peak = 350 * Math.exp(-dist*dist / 120000);
        const detail = 60 * Math.sin(x/50) * Math.cos(z/40);
        return { x: x * 1.2, y: 200 - (peak + detail), z: z };
    },

    snowflake: (i, total) => {
        const branch = i % 6;
        const branchProgress = Math.floor(i / 6) / (total / 6); 
        const angle = (branch / 6) * Math.PI * 2;
        const radius = branchProgress * 400;
        const detail = Math.sin(branchProgress * 25) * 40 * branchProgress;
        const width = (Math.random() - 0.5) * 30 * (1-branchProgress);
        const bx = radius;
        const by = detail + width;
        const rx = bx * Math.cos(angle) - by * Math.sin(angle);
        const ry = bx * Math.sin(angle) + by * Math.cos(angle);
        return { x: rx, y: ry, z: (Math.random() - 0.5) * 30 };
    }
};

// --- 3. ç²’å­ç³»ç»Ÿ ---
class Particle {
    constructor(index) {
        this.index = index;
        this.x = 0; this.y = 0; this.z = 0;
        this.ox = 0; this.oy = 0; this.oz = 0; 
        this.tx = 0; this.ty = 0; this.tz = 0;
        
        this.initColor();
        const pos = MathShapes.chaos(index, CONFIG.particleCount);
        this.x = this.ox = this.tx = pos.x;
        this.y = this.oy = this.ty = pos.y;
        this.z = this.oz = this.tz = pos.z;
    }

    initColor() {
        const range = CONFIG.baseHueMax - CONFIG.baseHueMin;
        this.baseHue = CONFIG.baseHueMin + Math.random() * range;
        this.lightness = 50 + Math.random() * 40; 
    }

    update(progress, state, audioBoost) {
        const ease = t => t < .5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1;
        const p = ease(progress);

        if (state === STATES.FORMING || state === STATES.DISPERSING) {
            this.x = this.ox + (this.tx - this.ox) * p;
            this.y = this.oy + (this.ty - this.oy) * p;
            this.z = this.oz + (this.tz - this.oz) * p;
        } else if (state === STATES.HOLDING) {
            // [ä¼˜åŒ–] å¤§å¹…å‡å¼±æŠ–åŠ¨ (Jitter Reduction)
            // åŸºç¡€æŠ–åŠ¨é¢‘ç‡ä» 0.02 é™è‡³ 0.005ï¼Œå¹…åº¦ç³»æ•°å¤§å¹…é™ä½
            
            let currTx = this.tx;
            let currTy = this.ty;
            let currTz = this.tz;

            // å½¢æ€å¾®åŠ¨
            if (currentShapeName === 'whale') {
                const wave = Math.sin(shapeUpdateTimer * 0.003 + this.x * 0.004);
                currTz += wave * 15; // å‡å°æ‘†åŠ¨å¹…åº¦
            } else if (currentShapeName === 'flower') {
                 const scale = 1 + Math.sin(shapeUpdateTimer * 0.0015) * 0.03;
                 currTx *= scale; currTy *= scale; currTz *= scale;
            }

            // éŸ³é¢‘æŠ–åŠ¨ï¼šä»…åœ¨ä½éŸ³å¼ºæ—¶æ‰æœ‰æ˜æ˜¾ååº”ï¼Œå¹³æ—¶éå¸¸å¹³æ»‘
            // ç³»æ•°ä» 8 é™è‡³ 2
            const jitter = Math.sin(Date.now() * 0.005 + this.index) * (0.2 + audioBoost * 2.0);
            
            this.x = currTx + jitter;
            this.y = currTy + jitter;
            this.z = currTz + jitter;
        } else {
            this.x += Math.cos(this.index + Date.now()*0.001) * 0.2;
            this.y += Math.sin(this.index + Date.now()*0.001) * 0.2;
        }

        // 3D æŠ•å½±
        let x1 = this.x * Math.cos(MOUSE.rotY) - this.z * Math.sin(MOUSE.rotY);
        let z1 = this.x * Math.sin(MOUSE.rotY) + this.z * Math.cos(MOUSE.rotY);
        let y2 = this.y * Math.cos(MOUSE.rotX) - z1 * Math.sin(MOUSE.rotX);
        let z2 = this.y * Math.sin(MOUSE.rotX) + z1 * Math.cos(MOUSE.rotX);

        const scale = CONFIG.zoom / (CONFIG.zoom + z2);
        this.sx = x1 * scale + w / 2;
        this.sy = y2 * scale + h / 2;
        this.scale = scale;
        this.depth = z2;
    }

    draw(ctx, audioBoost) {
        if (this.scale <= 0) return;
        
        const size = CONFIG.baseSize * this.scale * (1 + audioBoost * 0.5);
        const finalHue = this.baseHue + CONFIG.hueOffset + (audioBoost * 30);
        const finalLight = Math.min(100, this.lightness * CONFIG.brightness + (audioBoost * 20));
        const alpha = Math.min(1, (this.scale - 0.1) * 1.2);

        ctx.fillStyle = `hsla(${finalHue}, 80%, ${finalLight}%, ${alpha})`;
        ctx.beginPath();
        ctx.arc(this.sx, this.sy, size, 0, Math.PI * 2);
        ctx.fill();
    }
}

// --- 4. ç³»ç»Ÿæ§åˆ¶ ---
function init() {
    canvas = document.getElementById('canvas');
    ctx = canvas.getContext('2d');
    resize();
    window.addEventListener('resize', resize);
    
    setupUI();
    setupSettings();
    updateParticleCount();
    setupInteraction();
    loop();
}

function resize() {
    w = canvas.width = window.innerWidth;
    h = canvas.height = window.innerHeight;
}

function updateParticleCount() {
    const newCount = CONFIG.particleCount;
    particles = [];
    for(let i=0; i<newCount; i++) particles.push(new Particle(i));
    if (currentState !== STATES.IDLE && currentState !== STATES.DISPERSING) {
         setTargetShape(currentShapeName);
    }
}

function analyzeIntent() {
    if (!analyser) return 'chaos';
    analyser.getByteFrequencyData(dataArray);
    const len = dataArray.length;
    let low = 0, mid = 0, high = 0;
    
    for(let i=0; i<len*0.2; i++) low += dataArray[i];
    for(let i=len*0.2; i<len*0.6; i++) mid += dataArray[i];
    for(let i=len*0.6; i<len; i++) high += dataArray[i];
    low /= (len*0.2); mid /= (len*0.4); high /= (len*0.4);

    if (low > 140 && low > high * 1.1) return 'whale';    
    if (high > 120 && high > mid) return 'snowflake';     
    if (mid > low && mid > high) return 'flower';         
    return Math.random() > 0.5 ? 'mountain' : 'flower';   
}

function setTargetShape(shapeName) {
    currentShapeName = shapeName;
    const generator = MathShapes[shapeName] || MathShapes.chaos;
    particles.forEach((p, i) => {
        p.ox = p.x; p.oy = p.y; p.oz = p.z;
        const target = generator(i, CONFIG.particleCount);
        p.tx = target.x; p.ty = target.y; p.tz = target.z;
    });
}

function getShapeNameCN(name) {
    const map = { 'whale': 'æ·±æµ· Â· é²¸', 'flower': 'è™šç©º Â· èŠ±', 'mountain': 'å¹»å¢ƒ Â· å±±', 'snowflake': 'æ™¶ä½“ Â· é›ª', 'chaos': 'æ··æ²Œ' };
    return map[name] || name;
}

// --- 5. æ¸²æŸ“å¾ªç¯ (å«å¢å¼ºè¿çº¿é€»è¾‘) ---
function loop() {
    ctx.fillStyle = `rgba(5, 5, 12, ${CONFIG.trailAlpha})`;
    ctx.fillRect(0, 0, w, h);

    const now = Date.now();
    shapeUpdateTimer = now;
    let audioBoost = 0;

    if (isPlaying && analyser) {
        analyser.getByteFrequencyData(dataArray);
        let sum = 0;
        for(let i=0; i<20; i++) sum += dataArray[i];
        audioBoost = (sum / 20 / 255);
    }

    // çŠ¶æ€æ›´æ–°
    if (isPlaying) {
        const elapsed = now - stateStartTime;
        let progress = 0;
        switch (currentState) {
            case STATES.IDLE: switchState(STATES.FORMING); break;
            case STATES.FORMING: 
                progress = Math.min(elapsed / 5000, 1);
                updateStatus(`æ­£åœ¨å‡ç»“: ${getShapeNameCN(currentShapeName)} (${(progress*100).toFixed(0)}%)`);
                if (progress >= 1) switchState(STATES.HOLDING);
                break;
            case STATES.HOLDING: 
                updateStatus(`æ„è±¡ç»´æŒ: ${getShapeNameCN(currentShapeName)}`);
                if (elapsed > 10000) switchState(STATES.DISPERSING);
                break;
            case STATES.DISPERSING: 
                progress = Math.min(elapsed / 5000, 1);
                updateStatus(`æ„è±¡æ¶ˆæ•£... ${(progress*100).toFixed(0)}%`);
                if (progress >= 1) switchState(STATES.FORMING);
                break;
        }
        if (!MOUSE.isDown) MOUSE.rotY += CONFIG.rotationSpeed * (1 + audioBoost);
        particles.forEach(p => p.update(progress, currentState, audioBoost));
    } else {
        updateStatus("ç­‰å¾…éŸ³é¢‘ä¿¡å·...");
        particles.forEach(p => p.update(0, STATES.IDLE, 0));
        MOUSE.rotY += 0.0005;
    }

    particles.sort((a, b) => b.depth - a.depth);
    
    // --- [ä¼˜åŒ–] å¢å¼ºè¿çº¿æ•ˆæœé€»è¾‘ ---
    // å‘¼å¸å› å­ï¼šæ­£å¼¦æ³¢ï¼Œå‘¨æœŸçº¦3ç§’
    const rawBreath = (Math.sin(now * 0.002) + 1) / 2; 
    // è®©å‘¼å¸æ›²çº¿æ›´é™¡å³­ï¼Œæš—çš„æ—¶å€™æ›´æš—ï¼Œäº®çš„æ—¶å€™æ›´äº®
    const breathContrast = Math.pow(rawBreath, 2); 

    // ç©ºé—´æ³¢çº¹å› å­ï¼šåŸºäºæ—¶é—´çš„ç›¸ä½åç§»
    const ripplePhase = now * 0.003;

    if (CONFIG.trailAlpha > 0.1) {
        // [å¢å¼º] å¢åŠ è¿çº¿è·ç¦»é˜ˆå€¼ (ä»50å¢åŠ åˆ°80)
        const connDist = 80;
        const checkRange = CONFIG.particleCount > 1500 ? 5 : 12;

        for (let i = 0; i < particles.length; i++) {
            const p = particles[i];
            p.draw(ctx, audioBoost); // ç»˜åˆ¶ç²’å­

            if (p.scale > 0.3) {
                for (let j = i + 1; j < Math.min(particles.length, i + checkRange); j++) {
                    const p2 = particles[j];
                    const dx = p.sx - p2.sx;
                    const dy = p.sy - p2.sy;

                    if (Math.abs(dx) < connDist && Math.abs(dy) < connDist) {
                        const d = Math.sqrt(dx*dx + dy*dy);
                        if (d < connDist) {
                            // è®¡ç®—å±å¹•ä¸­å¿ƒçš„è·ç¦»ï¼Œç”¨äºåˆ¶é€ æ³¢çº¹æ¶Ÿæ¼ª
                            // å±å¹•ä¸­å¿ƒ (w/2, h/2)
                            const screenCX = w/2; 
                            const screenCY = h/2;
                            const distFromCenter = Math.sqrt(Math.pow(p.sx - screenCX, 2) + Math.pow(p.sy - screenCY, 2));
                            
                            // [æ–°å¢] æ¶Ÿæ¼ªæ•ˆæœè®¡ç®—
                            // æ³¢çº¹éšè·ç¦»äº§ç”Ÿæ­£å¼¦å˜åŒ–
                            const ripple = Math.sin(distFromCenter * 0.01 - ripplePhase);
                            const rippleFactor = (ripple + 1) / 2; // 0-1

                            // åŸºç¡€é€æ˜åº¦
                            let alpha = (1 - d/connDist);
                            
                            // [å¢å¼º] å åŠ å‘¼å¸ç¯ (å¤§å¹…å¢å¼ºè¡°å‡æ•ˆæœ)
                            // åŸºç¡€ 0.1 + å‘¼å¸ 0.9 -> å¯¹æ¯”åº¦æå¼º
                            const breathAlpha = 0.1 + 0.9 * breathContrast; 
                            
                            // [å¢å¼º] å åŠ æ¶Ÿæ¼ª (è®©å…‰çº¿æœ‰æµåŠ¨æ„Ÿ)
                            const rippleAlpha = 0.4 + 0.6 * rippleFactor;

                            alpha = alpha * p.scale * CONFIG.brightness * breathAlpha * rippleAlpha;

                            // é¢œè‰²å¤„ç†
                            const hue = p.baseHue + CONFIG.hueOffset;
                            
                            // [å¢å¼º] çº¿æ¡å®½åº¦éšè·ç¦»å’Œé€è§†å˜åŒ–
                            const lineWidth = (1 - d/connDist) * p.scale * 1.5;

                            ctx.lineWidth = lineWidth;
                            ctx.strokeStyle = `hsla(${hue}, 70%, 75%, ${alpha})`;
                            ctx.beginPath();
                            ctx.moveTo(p.sx, p.sy);
                            ctx.lineTo(p2.sx, p2.sy);
                            ctx.stroke();
                        }
                    }
                }
            }
        }
    } else {
        particles.forEach(p => p.draw(ctx, audioBoost));
    }

    requestAnimationFrame(loop);
}

function switchState(newState) {
    currentState = newState;
    stateStartTime = Date.now();
    if (newState === STATES.FORMING) {
        const nextShape = analyzeIntent();
        setTargetShape(nextShape);
    } else if (newState === STATES.DISPERSING) {
        setTargetShape('chaos');
    }
}

function updateStatus(text) {
    document.getElementById('status-bar').innerText = text;
}

// --- 7. äº‹ä»¶ç»‘å®š ---
function setupInteraction() {
    canvas.addEventListener('mousedown', e => {
        MOUSE.isDown = true;
        MOUSE.lastX = e.clientX;
        MOUSE.lastY = e.clientY;
    });
    window.addEventListener('mousemove', e => {
        if (MOUSE.isDown) {
            MOUSE.rotY += (e.clientX - MOUSE.lastX) * 0.005;
            MOUSE.rotX -= (e.clientY - MOUSE.lastY) * 0.005;
            MOUSE.lastX = e.clientX;
            MOUSE.lastY = e.clientY;
        }
    });
    window.addEventListener('mouseup', () => MOUSE.isDown = false);
    canvas.addEventListener('wheel', e => {
        e.preventDefault();
        CONFIG.zoom = Math.max(200, Math.min(CONFIG.zoom + e.deltaY * -1, 1500));
    }, { passive: false });
}

function setupSettings() {
    const bindSlider = (id, configKey, displayId, transformFn, callback) => {
        const el = document.getElementById(id);
        const disp = document.getElementById(displayId);
        el.addEventListener('input', (e) => {
            const val = parseFloat(e.target.value);
            CONFIG[configKey] = transformFn ? transformFn(val) : val;
            if (disp) disp.innerText = transformFn ? transformFn(val) : val;
            
            if (id === 'rng-size') disp.innerText = val + 'px';
            if (id === 'rng-hue') disp.innerText = (val > 0 ? '+' : '') + val + 'Â°';
            if (id === 'rng-bright') disp.innerText = val + '%';
            if (id === 'rng-trail') disp.innerText = val + '%'; 
            if (id === 'rng-trail') CONFIG.trailAlpha = val / 100;
            if (id === 'rng-bright') CONFIG.brightness = val / 100;

            if (callback) callback();
        });
    };

    bindSlider('rng-count', 'particleCount', 'val-count', null, updateParticleCount);
    bindSlider('rng-size', 'baseSize', 'val-size');
    bindSlider('rng-hue', 'hueOffset', 'val-hue');
    bindSlider('rng-bright', 'brightness', 'val-bright', val => val/100); 
    bindSlider('rng-trail', 'trailAlpha', 'val-trail', val => val/100);
}

function setupUI() {
    const fileInput = document.getElementById('file-upload');
    const playBtn = document.getElementById('btn-play');
    
    fileInput.addEventListener('change', e => {
        const file = e.target.files[0];
        if(!file) return;
        document.getElementById('song-info').innerText = "è§£æä¸­...";
        if (audioCtx) try{ audioCtx.close() }catch(e){}
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        
        const reader = new FileReader();
        reader.onload = evt => {
            audioCtx.decodeAudioData(evt.target.result, buf => {
                audioBuffer = buf;
                document.getElementById('song-info').innerText = file.name;
                playBtn.disabled = false;
                updateStatus("éŸ³ä¹å·²åŠ è½½ï¼Œç­‰å¾…æ’­æ”¾");
            }, () => alert("è§£ç å¤±è´¥"));
        };
        reader.readAsArrayBuffer(file);
    });

    playBtn.addEventListener('click', () => {
        if(!audioBuffer) return;
        if(audioCtx.state === 'suspended') audioCtx.resume();
        startAudio();
    });

    document.getElementById('btn-pause').addEventListener('click', () => {
        if(audioSource) audioSource.stop();
        isPlaying = false;
        playBtn.disabled = false;
        document.getElementById('btn-pause').disabled = true;
    });

    document.getElementById('btn-reset').addEventListener('click', () => {
        setTargetShape('chaos');
        particles.forEach(p => {
            const pos = MathShapes.chaos(p.index, CONFIG.particleCount);
            p.x = p.ox = p.tx = pos.x;
            p.y = p.oy = p.ty = pos.y;
            p.z = p.oz = p.tz = pos.z;
        });
        currentState = STATES.IDLE;
        MOUSE.rotX = 0; MOUSE.rotY = 0;
        if(isPlaying) switchState(STATES.FORMING);
    });
}

function startAudio() {
    if(audioSource) try{ audioSource.stop() }catch(e){}
    audioSource = audioCtx.createBufferSource();
    audioSource.buffer = audioBuffer;
    analyser = audioCtx.createAnalyser();
    analyser.fftSize = 256;
    dataArray = new Uint8Array(analyser.frequencyBinCount);
    
    audioSource.connect(analyser);
    analyser.connect(audioCtx.destination);
    audioSource.start(0);
    
    isPlaying = true;
    stateStartTime = Date.now();
    currentState = STATES.IDLE;
    
    document.getElementById('btn-play').disabled = true;
    document.getElementById('btn-pause').disabled = false;
    
    audioSource.onended = () => {
        isPlaying = false;
        currentState = STATES.IDLE;
        document.getElementById('btn-play').disabled = false;
        document.getElementById('btn-pause').disabled = true;
        updateStatus("æ’­æ”¾ç»“æŸ");
    };
}

// å¯åŠ¨
window.onload = init;
</script>
</body>
</html>